# Звіт до домашньої роботи №3

**Варіант:** 18 - Мінімальне кістякове дерево з обмеженням на ступінь вершин

### 1. Постановка задачі

Дано неорієнтований зважений граф G=(V,E) та число d. Потрібно знайти таке кістякове дерево (підграф, що з’єднує всі вершини і є деревом) мінімальної сумарної ваги, що ступінь будь-якої вершини в цьому дереві не перевищує d. Якщо такого дерева не існує, видати відповідне повідомлення.

**Вхідні дані:**
* Неорієнтований зважений граф G = (V, E)
* Число d — максимальний дозволений ступінь вершини

**Вихідні дані:**
* Список ребер кісткового дерева мінімальної сумарної ваги
* Сумарна вага дерева
* Або повідомлення про відсутність такого дерева

**Обмеження:**
* Ступінь будь-якої вершини в деревi не повинен перевищувати d
* Дерево повинно з'єднувати всі вершини графа

### 2. Теоретична частина
**2.1. Складність задачі**

Задача побудови мінімального кісткового дерева з обмеженням на ступінь вершин (Degree-Constrained Minimum Spanning Tree, DCMST) є NP-важкою. Це означає, що не існує відомого поліноміального алгоритму, який гарантовано знаходить оптимальне рішення для всіх випадків.

**2.2. Відмінність від класичного MST**

Класична задача MST (без обмеження на ступінь) розв'язується ефективно за допомогою алгоритмів:
* Алгоритм Крускала: O(E log E)
* Алгоритм Прима: O(E log V)

Однак додавання обмеження на ступінь вершин робить задачу значно складнішою, оскільки:
- Жадібний підхід не завжди працює
- Потрібно враховувати глобальні обмеження на структуру дерева
- Може не існувати розв'язку при певних значеннях d

**2.3. Необхідна умова існування розв'язку**

Для існування кісткового дерева з обмеженням на ступінь необхідно, щоб:
* d ≥ 1 (мінімальний ступінь для з'єднаних вершин)
* Для дерева з n вершин: d ≥ 2 для внутрішніх вершин
* При d = 1 дерево може існувати тільки для графа-ланцюга з 2 вершин

### 3. Опис реалізованих алгоритмів
**3.1. Жадібний алгоритм з обмеженням на ступінь**

Ідея: Модифікація алгоритму Крускала з перевіркою ступенів вершин.

Алгоритм:
```bash
1. Відсортувати всі ребра за вагою (зростання)
2. Ініціалізувати Union-Find для перевірки зв'язності
3. Ініціалізувати масив степенів всіх вершин нулями
4. Для кожного ребра (u, v, weight) у відсортованому порядку:
   a. Якщо degree[u] < d і degree[v] < d:
      i.  Якщо u і v у різних компонентах зв'язності:
          - Додати ребро до дерева
          - Об'єднати компоненти
          - Збільшити degree[u] і degree[v]
5. Перевірити, чи отримали дерево (n-1 ребер і зв'язність)
```

**Часова складність:** O(E log E + E α(V))
* O(E log E) — сортування ребер
* O(E α(V)) — операції Union-Find, де α — обернена функція Аккермана

Переваги: Швидкий; Простий у реалізації; Добре працює на практиці для багатьох випадків

Недоліки: Не гарантує оптимальний розв'язок; Не гарантує знаходження розв'язку, навіть якщо він існує

**3.2. Повний перебір з поверненням (Backtracking)**

Ідея: Систематичний перебір усіх можливих комбінацій ребер з відсіканням неперспективних гілок.

Алгоритм:
```bash
1. Відсортувати ребра за вагою
2. Викликати рекурсивну функцію:
   backtrack(index, selected_edges, degrees, current_weight):
   a. Якщо |selected_edges| = n-1:
      - Перевірити зв'язність
      - Оновити найкраще рішення якщо потрібно
   b. Якщо index >= |edges|: повернутись
   c. Якщо current_weight >= best_weight: відсікти (pruning)
   d. Спробувати додати ребро edges[index]:
      - Якщо ступені дозволяють: рекурсія з доданим ребром
   e. Спробувати НЕ додавати ребро: рекурсія без нього
```

**Часова складність:** O(2^E) у найгіршому випадку

Відсікання (pruning):
- Перевірка поточної ваги: якщо вже більша за найкращу
- Перевірка кількості доступних ребер
- Перевірка обмежень на ступені

Переваги: Знаходить оптимальне рішення; Підходить для малих графів (n ≤ 10)

Недоліки: Експоненційна складність; Непридатний для великих графів

**3.3. Метод гілок та меж (Branch and Bound)**

Ідея: Покращення backtracking за допомогою нижньої межі вартості.

Алгоритм:
```bash
1. Початкове рішення: жадібний алгоритм
2. Рекурсивний пошук з обчисленням нижньої межі:
   search(index, selected, degrees, weight, uf):
   a. Обчислити lower_bound для поточного стану
   b. Якщо lower_bound >= best_weight: відсікти
   c. Спробувати додати/не додати ребро
   d. Рекурсія для обох варіантів
```
Обчислення нижньої межі:

```bash
1. Вага вже обраних ребер
2. Додати мінімальні ваги для решти ребер, що потрібні:
   - Виконати жадібний алгоритм на залишкових ребрах
   - Врахувати поточні ступені та зв'язність
```

**Часова складність:** O(2^E) у найгіршому випадку, але на практиці значно швидше

Переваги: Знаходить оптимальне рішення; Швидше за простий backtracking завдяки відсіканню; Підходить для середніх графів (n ≤ 15)

Недоліки: Все ще експоненційна складність; Потребує обчислення нижніх меж

**3.4. Union-Find (Disjoint Set Union)**

Допоміжна структура даних для ефективної перевірки та об'єднання компонент зв'язності.

**Операції:**
* find(x) — знайти корінь множини, що містить x: O(α(n))
* union(x, y) — об'єднати множини: O(α(n))
* is_connected(n) — перевірка зв'язності графа: O(n α(n))

**Оптимізації:**
* Path compression (стиснення шляху)
* Union by rank (об'єднання за рангом)

### 4. Деталі реалізації
**4.1. Структура класів**

**UnionFind:**
* parent — масив батьків для кожної вершини
* rank — ранги для оптимізації об'єднання
    
Методи: find, union, is_connected, copy

**DegreeConstrainedMST:**
* n — кількість вершин
* edges — список ребер, відсортований за вагою
* max_degree — обмеження d
* adjacency — список суміжності

**4.2. Основні методи**

greedy_with_degree_constraint(): Швидкий жадібний підхід, завжди виконується першим

backtracking_search(): Повний перебір з відсіканням; для графів з n ≤ 10

branch_and_bound(): Для графів з 10 < n ≤ 15; Використовує нижні межі

solve():
- Головний метод, який вибирає алгоритм
- Автоматичний вибір на основі розміру графа

**4.3. Особливості реалізації**

Перевірка зв'язності:
```bash
pythondef is_connected(edges):
    uf = UnionFind(n)
    for u, v, _ in edges:
        uf.union(u, v)
    return uf.is_connected(n)
```

**Обчислення нижньої межі:**
1. Використовується жадібний підхід на залишкових ребрах
2. Враховує поточні ступені вершин
3. Повертає ∞, якщо неможливо додати потрібну кількість ребер
