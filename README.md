# Звіт

### 1.1 Мета роботи
Метою даної роботи є дослідження та порівняльний аналіз різних підходів до організації структур даних для зберігання та обробки інформації про студентів. Робота включає реалізацію трьох варіантів баз даних з різними стратегіями індексування, тестування їх продуктивності на наборах даних різного розміру та порівняння ефективності алгоритмів сортування.

### 1.2 Варіант завдання

Варіант операцій: V2 зі співвідношенням 2:100:30

Варіант сортування: S6 (сортування за датою народження: місяць, день)

Тестові набори даних: 100, 1000, 10000, 100000 студентів

### 1.3 Специфікація операцій V2

Операція 1 (Op1): Пошук студентів за конкретною датою народження (місяць і день) - 2 операції у співвідношенні

Операція 2 (Op2): Оновлення групи студента за його email - 100 операцій у співвідношенні

Операція 3 (Op3): Пошук групи з найбільшою кількістю студентів, що мають однакову дату народження - 30 операцій у співвідношенні

### 2. Реалізовані бази даних

**2.1 ArrayListDatabaseV2**

Принцип роботи: Найпростіша реалізація, яка зберігає всіх студентів у звичайному ArrayList без додаткових структур даних.

**Складність операцій:**

findStudentsByBirthday: O(n) - повний перебір списку

updateGroupByEmail: O(n) - пошук студента лінійним переглядом

findGroupWithMostSameBirthdays: O(n) - один прохід з підрахунком

Переваги:
* Мінімальне використання пам'яті
* Проста реалізація
* Немає додаткових накладних витрат на підтримку індексів

Недоліки:
* Повільний пошук за критеріями
* Погана масштабованість на великих даних

2.2 HashEmailDatabaseV2

Принцип роботи: Використовує дві hash-таблиці для прискорення операцій:

* emailMap: HashMap<String, Student> - індекс по email для швидкого пошуку студента
* birthMap: HashMap<String, List<Student>> - індекс по датах народження (ключ формату "month-day")

**Складність операцій:**

findStudentsByBirthday: O(1) в середньому - пряме звертання до hash-таблиці

updateGroupByEmail: O(1) в середньому - пошук через emailMap

findGroupWithMostSameBirthdays: O(n) - потрібен перебір для підрахунку

Переваги:
* Швидкий пошук за датою народження
* Швидке оновлення групи
* Збалансоване використання пам'яті

Недоліки:
* Операція пошуку групи все ще вимагає повного сканування
* Додаткові витрати пам'яті на індекси

2.3 FullIndexDatabaseV2

Принцип роботи: Повна індексація всіх операцій з використанням трьох структур даних:

* emailMap: HashMap<String, Student> - індекс по email
* birthMap: HashMap<String, List<Student>> - індекс по датах народження

groupBirthCountMap: HashMap<String, HashMap<String, Integer>> - вкладена структура для підрахунку кількості студентів з однаковою датою народження в кожній групі

**Складність операцій:**

findStudentsByBirthday: O(1) в середньому

updateGroupByEmail: O(1) в середньому - з автоматичним оновленням індексів

findGroupWithMostSameBirthdays: O(g×b) де g - кількість груп, b - середня кількість унікальних дат народження на групу (зазвичай << n)

Переваги:
* Найшвидша робота для всіх трьох операцій
* Оптимальна для частих запитів
* Постійна підтримка актуальності індексів

Недоліки:
* Найбільше використання пам'яті
* Складність підтримки консистентності індексів
* Повільніша ініціалізація

### 3. Реалізація сортування (S6)

3.1 Standard Sort

Використовує вбудований алгоритм сортування Java (Collections.sort / List.sort) з компаратором, який порівнює спочатку місяць народження, а потім день.
Алгоритм: Timsort (гібрид merge sort та insertion sort) Складність: O(n log n)

```bash
students.sort((a, b) -> {
    int monthComp = Integer.compare(a.m_birth_month, b.m_birth_month);
    if (monthComp != 0) return monthComp;
    return Integer.compare(a.m_birth_day, b.m_birth_day);
});
```

3.2 Counting Sort

Спеціалізована реалізація counting sort для сортування за датами народження. Використовує 372 "відра" (buckets): 12 місяців × 31 день = 372 можливі комбінації.
Алгоритм: Counting Sort з bucket-структурою Складність: O(n + k), де k = 372 (константа)

### 4 Методологія тестування

4.1 Вимірювання продуктивності

Тестування проводиться протягом 10 секунд для кожної конфігурації. Операції виконуються випадковим чином згідно зі співвідношенням 2:100:30:

З ймовірністю 2/132 виконується Op1 (пошук за датою)

З ймовірністю 100/132 виконується Op2 (оновлення групи)

З ймовірністю 30/132 виконується Op3 (пошук групи з максимумом)

Підраховується загальна кількість операцій за 10 секунд, що дає об'єктивну оцінку продуктивності.

4.2 Вимірювання пам'яті

Для точного вимірювання використання пам'яті:

1. Виконується подвійна garbage collection
2. Вимірюється heap та non-heap пам'ять до ініціалізації
3. Створюється та ініціалізується база даних
4. Повторюється garbage collection
5. Вимірюється пам'ять після ініціалізації
6. Обчислюється різниця

### 5. Аналіз графіків

5.1 Графік 1: Total Operations per Second

Що показує: Загальна продуктивність (операцій/секунду) на логарифмічній шкалі.

**Ключові спостереження:**

* FullIndex домінує на малих/середніх даних: 5.4М оп/сек (100 студентів), 2.5М (1K), 2.3М (10K)
* На 100K студентів різко падає до 3,839 оп/сек через накладні витрати на складні індекси
* HashEmail показує стабільну деградацію: 1.76М → 160K → 16K → 449 оп/сек
* ArrayList найповільніший: на 100K лише 382 оп/сек

Висновок: FullIndex найкращий для малих даних, але погано масштабується. HashEmail оптимальний для великих обсягів.

5.2 Графік 2: Memory Usage

Що показує: Абсолютне споживання пам'яті (логарифмічна шкала).

**Спостереження:**

* ArrayList: лінійне зростання 0 → 0.34 MB (найефективніший)
* HashEmail: показникове зростання до 5.48 MB (100K)
* FullIndex: максимум 12.64 MB (100K) - в 37 разів більше ніж ArrayList

Висновок: Складні індекси вимагають значних витрат пам'яті. ArrayList мінімальний, FullIndex найвитратніший.

5.3 Графік 3: Memory per Student

Що показує: Ефективність використання пам'яті (KB на одного студента).

**Спостереження:**

* ArrayList: практично 0 (~0.0035 KB/студент) - найкращий показник
* HashEmail: 0.20 KB → 0.055 KB зі зростанням даних (ефект масштабу)
* FullIndex: нелінійна поведінка 0.20 → 0.036 → 0.13 KB через складність вкладених структур

Висновок: ArrayList найщільніший, HashEmail добре амортизується, FullIndex має overhead.

5.4 Графік 4: Operation Performance (10K студентів)

Що показує: Розподіл виконаних операцій кожного типу за 10 секунд.

**Детальний розбір:**

* Op1 (пошук за датою): ArrayList 1,756 | HashEmail 2,552 | FullIndex 354,791 - індексація дає 202x прискорення
* Op2 (оновлення групи): ArrayList 84,924 | HashEmail 124,507 | FullIndex 17,706,388 - 208x прискорення, складає 76% всіх операцій
* Op3 (пошук групи макс): ArrayList 25,418 | HashEmail 37,446 | FullIndex 5,314,417 - 209x прискорення завдяки попередньо обчисленим лічильникам

Співвідношення (FullIndex): 354,791 : 17,706,388 : 5,314,417 ≈ 1.5:75:22.7 (близько до заданого 2:100:30)

Висновок: FullIndex рівномірно прискорює всі три операції. Індексація критично важлива для Op1 та Op2.

5.5 Графік 5: Performance vs Memory Usage

Що показує: Scatter plot компромісу продуктивність/пам'ять для всіх конфігурацій.

**Інтерпретація:**

* Малі дані (100-1K): FullIndex у верхньому лівому куті - оптимум (висока швидкість, мало пам'яті)
* Середні дані (10K): FullIndex тримає лідерство з 2.3М оп/сек при 0.36 MB
* Великі дані (100K):
  - FullIndex: 3,839 оп/сек при 12.64 MB (top-right)
  - HashEmail: 449 оп/сек при 5.48 MB (центр, золота середина)
  - ArrayList: 382 оп/сек при 0.34 MB (bottom-left, мінімум RAM)

Висновок: HashEmail - найкращий баланс для production. ArrayList - для embedded систем. FullIndex - для real-time аналітики малих даних.

5.6 Графік 6: Sorting Performance (S6)

Що показує: Час сортування 100K студентів двома алгоритмами.

**Результати:**

* Standard Sort: 25 мс
* Counting Sort: 11 мс
* Прискорення: 2.27x (в 2.27 рази швидше)

Standard Sort (Timsort): O(n log n) ≈ 1.66M порівнянь об'єктів
Counting Sort: O(n + k) ≈ 100K операцій, один прохід + розподіл по 372 buckets
Counting уникає порівнянь, використовує обмежений діапазон дат (12 місяців × 31 день)

Обмеження: Counting Sort працює тільки для дискретних діапазонів (не підходить для сортування за rating або ім'ям).

Висновок: Для календарних даних спеціалізовані алгоритми значно ефективніші універсальних.

### 6. Висновки

Порівняння реалізацій

**ArrayListDatabaseV2:**

Використання: малі дані (<1K), обмежена пам'ять, embedded системи

Плюси: 0.0035 KB/студент, проста підтримка

Мінуси: 382 оп/сек на 100K, O(n) для всіх операцій

**HashEmailDatabaseV2:**

Використання: універсальне рішення для 1K-50K записів

Плюси: баланс 449 оп/сек при 5.48 MB, стабільна масштабованість

Мінуси: Op3 залишається O(n)

**FullIndexDatabaseV2:**

Використання: критична швидкість, малі/середні дані (до 10K)

Плюси: до 5.4М оп/сек, всі операції O(1)-O(g)

Мінуси: 12.64 MB пам'яті, погана масштабованість на 100K+

Висновки по сортуванню

Counting Sort показав 2.27x прискорення (11 мс vs 25 мс) завдяки лінійній складності O(n+372) проти O(n log n). Ефективний для обмежених діапазонів значень, але не універсальний. Для календарних даних - оптимальний вибір.

### Вивід програми:

```bash
javac -d bin src/Main.java src/student/*.java src/student/impl/*.java src/student/sorter/*.java
java -cp bin Main
```

```bash
Loaded 100000 students

=== ArrayList Database ===
Testing with 100 students:
Memory usage: 0.00 MB
Operations completed - Op1: 257650, Op2: 12882289, Op3: 3868854, Total: 17008793
Testing with 1000 students:
Memory usage: 0.00 MB
Operations completed - Op1: 21013, Op2: 1050945, Op3: 315286, Total: 1387244
Testing with 10000 students:
Memory usage: 0.03 MB
Operations completed - Op1: 1756, Op2: 84924, Op3: 25418, Total: 112098
Testing with 100000 students:
Memory usage: 0.34 MB
Operations completed - Op1: 51, Op2: 2901, Op3: 870, Total: 3822

=== HashEmail Database ===
Testing with 100 students:
Memory usage: 0.02 MB
Operations completed - Op1: 267231, Op2: 13363573, Op3: 4012717, Total: 17643521
Testing with 1000 students:
Memory usage: 0.10 MB
Operations completed - Op1: 24261, Op2: 1215505, Op3: 364614, Total: 1604380
Testing with 10000 students:
Memory usage: 0.40 MB
Operations completed - Op1: 2552, Op2: 124507, Op3: 37446, Total: 164505
Testing with 100000 students:
Memory usage: 5.48 MB
Operations completed - Op1: 58, Op2: 3420, Op3: 1011, Total: 4489

=== FullIndex Database ===
Testing with 100 students:
Memory usage: 0.02 MB
Operations completed - Op1: 825690, Op2: 41224082, Op3: 12373530, Total: 54423302
Testing with 1000 students:
Memory usage: 0.08 MB
Operations completed - Op1: 380875, Op2: 19011677, Op3: 5707135, Total: 25099687
Testing with 10000 students:
Memory usage: 0.36 MB
Operations completed - Op1: 354791, Op2: 17706388, Op3: 5314417, Total: 23375596
Testing with 100000 students:
Memory usage: 12.64 MB
Operations completed - Op1: 596, Op2: 29118, Op3: 8671, Total: 38385

=== Sorting Performance (S6) ===
Standard sort time: 25 ms
Counting sort time: 11 ms
Sorting correctness: true
Sorted data saved to data/students_sorted.csv
```
